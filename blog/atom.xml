<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://heighliner.dev/blog</id>
    <title>Heighliner Blog</title>
    <updated>2022-03-08T00:00:00.000Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://heighliner.dev/blog"/>
    <subtitle>Heighliner Blog</subtitle>
    <icon>https://heighliner.dev/img/favicon.ico</icon>
    <entry>
        <title type="html"><![CDATA[What is Heighliner Stack]]></title>
        <id>what-is-heighliner-stack</id>
        <link href="https://heighliner.dev/blog/what-is-heighliner-stack"/>
        <updated>2022-03-08T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[The Heighliner Stack provides an easy way to build complex cloud-native applications.]]></summary>
        <content type="html"><![CDATA[<p>The Heighliner Stack provides an easy way to build complex cloud-native applications.
It makes sure cloud native applications are developed and deployed with best practices.</p><p><img loading="lazy" alt="simplicity" src="/assets/images/simplicity-92dfb57865badf962255dbe3b5e74239.jpeg" width="714" height="616"></p><h2 class="anchor anchorWithStickyNavbar_mojV" id="complexity-of-building-cloud-native-applications">Complexity of building cloud-native applications<a class="hash-link" href="#complexity-of-building-cloud-native-applications" title="Direct link to heading">​</a></h2><p>The complexity of application architecture multiplies as the business grows. Support you begin with building a simple personal blog hosted on cloud. What platform and tech stack would you choose? The answer might be Heroku, WordPress, Netlify, or even GitHub pages. They are simple, cheap, and reliable enough for simple applications such as personal blogs. In this case, no one cares about micro-service, containers, Kubernetes, Autoscaling, GitOps, so on and so forth.</p><p><img loading="lazy" alt="archtecture" src="/assets/images/archtecture-100x-2850237d7660de6b82aac5a19822c77b.png" width="1468" height="882"></p><p>Nonetheless, modern enterprises, such as e-commerce and/or social platforms, have employed thousands of developers to build software in a monolithic application. As the number of developers grows, so does the complexity of building such an application. The micro-service architecture supports separating concerns of different teams and better cooperation. As a result, micro-service architecture gets more and more popular.</p><p>To support such micro-service trends, cloud native technologies has been born to satisfy modern application architecture. Developers want their applications to be highly available and fault-tolerant. But the number of applications gets 100x bigger so they can't be managed and operated in the old way. Therefore, concepts such as elastic scaling, distributed monitoring, and deployment strategies have emerged to solve such problems.</p><p><img loading="lazy" alt="cloud-native" src="/assets/images/cloud-native-5eb693cc23b19744be33773649240464.png" width="358" height="355"></p><p>Developers want their applications to be highly available and fault-tolerant. But micro-service pattern will increase the number of applications to 100x bigger. This will make it hard if not impossible to manage or operate. To support the micro-service trend, cloud native technologies has been born to satisfy modern requirements. Concepts such as service mesh, distributed tracing, continuous profling has emerged. Developers has been given the power to easily build CI/CD pipelines, elastic scaling solutions, observability stacks, canary deployment strategies, etc.</p><p>With great power comes great responsibility. Now the developers realize they spend more time dealing with infrastructure than buisness code. Soon they realize this is wrong -- they need to focus on buisness logic that generates revenue! This is a new problem that developers face in the cloud native journey.</p><h2 class="anchor anchorWithStickyNavbar_mojV" id="configuration-configuration-configuration">Configuration! Configuration! Configuration!<a class="hash-link" href="#configuration-configuration-configuration" title="Direct link to heading">​</a></h2><p>The sheer number of tooling in cloud native community is growing fast. Soon developers are overwhelmed by the configuration work.</p><p>Here is the Cloud Native Landsacpe of CNCF (<a href="https://l.cncf.io/" target="_blank" rel="noopener noreferrer">https://l.cncf.io/</a>)</p><p><img loading="lazy" alt="simplicity" src="/assets/images/landscape-1024x702-b29c9ac0199346a30888c2a7258cb3d3.jpeg" width="1024" height="702"></p><p>Turning this picture into a production toolchain requires thousands of lines of configuration. Terraform provides a good way to ochestrate the infrastructure. Kubernetes provides a good way to ochestrate the deployment architeture. But there is still no good way to ochestrate the development process and delivery workflow.</p><p>Consider the following questions:</p><ul><li>Should the source code and the Kubernetes Manifests be in the same Git repository?</li><li>What is the mapping relationship between branches and  environments?</li><li>What namespace monitoring metrics should Prometheus capture?</li><li>What dashboard and graph should Golang developers focus on?</li><li>What alert rules should be configured?</li><li>Should I use a self-built open source product or a commercial product?</li><li>How to remote debug container in Kubernetes cluster?</li></ul><p><img loading="lazy" alt="cloud-stack" src="/assets/images/cloud-stack-1b80cd9981d570174906c1284e2f0019.png" width="814" height="430"></p><p>Everyone wants to know the industry standards to make their decisions. Thus we need well-defined cloud-native best practices as a collection of all proven and reliable methods.</p><h2 class="anchor anchorWithStickyNavbar_mojV" id="preconfigured-best-practices">Preconfigured Best Practices<a class="hash-link" href="#preconfigured-best-practices" title="Direct link to heading">​</a></h2><p>We build these best practices into a project called Heighliner. Starting from developer-centric mind, we provides many pre-configured stacks covering popular programming languages and frameworks. For example, go-gin-stack is a toolchain preconfigured with the following tools and techniques:</p><ul><li>Golang</li><li>Git Repository(Currently provided by GitHub)</li><li>Gin Framework</li><li>Swagger</li><li>Vue.js</li><li>Gorm</li><li>Docker</li><li>CI pipeline(Currently provided by GitHub Actions)</li><li>ArgoCD</li><li>Mariadb</li><li>Redis</li><li>NATS</li><li>Helm</li><li>Kubernetes</li><li>Nocalhost</li><li>Prometheus</li><li>Grafana</li><li>Istio</li><li>Jaeger</li><li>Loki</li></ul><p>A toolchain composed of the above tools will support business development based on Golang. Preconfigured delivery flow speeds the DevOps process up.
Pre-configured observation capabilities covering logs, metrics and distributed tracing.
Database and messaging middleware ensures applications can handle stateful and asynchronous tasks with ease.
GitOps based on ArgoCD and helm makes application publishing simple and efficient.</p><p><img loading="lazy" alt="gin-vue-stack" src="/assets/images/gin-vue-stack-9a21422b489e3e5b245db41fd2bad914.jpg" width="1920" height="1080"></p><p>Based on a stack like this, developers can spin a cloud-navite application up in minutes without the complexcity of configuration. Stack is open source and transparent, which ensures that developers have no barriers to understand all the process of code from editing to deployment.</p><p>With this convention-over-configuration mindset, developers can enjoy the coding-testing-commiting inner development loop.</p><h2 class="anchor anchorWithStickyNavbar_mojV" id="whats-next">What's next?<a class="hash-link" href="#whats-next" title="Direct link to heading">​</a></h2><p>A developer console can be built to display key states in delivery flow, such as build results, deployment versions, logs, traffic control rules, alerts etc.
Developers can get any useful information in that console and can manipulate the application the way they want.</p>]]></content>
        <author>
            <name>Zhenwei Wang</name>
            <uri>https://github.com/jack230320</uri>
        </author>
        <category label="Heighliner" term="Heighliner"/>
        <category label="Cloud Native" term="Cloud Native"/>
        <category label="Stack" term="Stack"/>
    </entry>
</feed>